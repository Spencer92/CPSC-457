diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..1530978
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+*.o
\ No newline at end of file
diff --git a/affinity_mask_assignment.patch b/affinity_mask_assignment.patch
new file mode 100644
index 0000000..72d5267
--- /dev/null
+++ b/affinity_mask_assignment.patch
@@ -0,0 +1,254 @@
+From b7353a75e557b9f18075be410efe7ff213a097c6 Mon Sep 17 00:00:00 2001
+From: priyaa <priyaa.mirra@gmail.com>
+Date: Thu, 25 Jun 2015 15:43:07 -0600
+Subject: [PATCH 1/2] Assignment 1 patch
+
+---
+ src/include/kostypes.h   |  3 +++
+ src/runtime/Runtime.h    |  4 ++--
+ src/runtime/Scheduler.cc | 29 +++++++++++++++++++++++++++--
+ src/runtime/Scheduler.h  |  3 ++-
+ src/runtime/Thread.h     |  9 ++++++++-
+ 5 files changed, 42 insertions(+), 6 deletions(-)
+
+diff --git a/src/include/kostypes.h b/src/include/kostypes.h
+index be993d3..650f684 100644
+--- a/src/include/kostypes.h
++++ b/src/include/kostypes.h
+@@ -26,12 +26,15 @@ typedef  int64_t sword;
+ typedef mword vaddr;
+ typedef mword paddr;
+ 
++typedef mword cpu_set_t;
++
+ static const mword charbits = 8;
+ static const mword bytebits = 8;
+ 
+ typedef char  buf_t;
+ typedef char* bufptr_t;
+ typedef const char* cbufptr_t;
++
+ #else
+ #error unsupported architecture: only __x86_64__ supported at this time
+ #endif
+diff --git a/src/runtime/Runtime.h b/src/runtime/Runtime.h
+index dfe7125..4bd3e4b 100644
+--- a/src/runtime/Runtime.h
++++ b/src/runtime/Runtime.h
+@@ -69,8 +69,8 @@ namespace Runtime {
+ 
+   struct RealLock {
+     RealLock() { LocalProcessor::lock(true); }    // disable IRQs
+-    // destructor not needed
+-  };
++    ~RealLock() { LocalProcessor::unlock(true); } // deflate lock count, enable IRQs 
++ };
+ 
+   /**** AddressSpace-related interface ****/
+ 
+diff --git a/src/runtime/Scheduler.cc b/src/runtime/Scheduler.cc
+index 7d760c3..0ae7581 100644
+--- a/src/runtime/Scheduler.cc
++++ b/src/runtime/Scheduler.cc
+@@ -44,7 +44,9 @@ inline void Scheduler::switchThread(Scheduler* target, Args&... a) {
+   CHECK_LOCK_MIN(sizeof...(Args));
+   Thread* nextThread;
+   readyLock.acquire();
+-  for (mword i = 0; i < (target ? idlePriority : maxPriority); i += 1) {
++//  for (mword i = 0; i < (target ? idlePriority : maxPriority); i += 1) {
++  for (mword i = 0; i < ((target == this) ? idlePriority : maxPriority);
++i += 1) {
+     if (!readyQueue[i].empty()) {
+       nextThread = readyQueue[i].pop_front();
+       readyCount -= 1;
+@@ -111,11 +113,29 @@ void Scheduler::resume(Thread& t) {
+   else Runtime::getScheduler()->enqueue(t);
+ }
+ 
++
++
+ void Scheduler::preempt() {               // IRQs disabled, lock count inflated
+ #if TESTING_NEVER_MIGRATE
+   switchThread(this);
+ #else /* migration enabled */
+-  Scheduler* target = Runtime::getCurrThread()->getAffinity();
++  //Scheduler* target =  Runtime::getCurrThread()->getAffinity();
++  Scheduler *target = nullptr;
++  mword affinityMask = Runtime::getCurrThread()->getAffinityMask();
++
++  if( affinityMask == 0 ) {
++	  /* use Martin's code when no affinity is set via bit mask */
++	  target =  Runtime::getCurrThread()->getAffinity();
++   }  else {
++	  /* CPSC457l: Add code here to scan the affinity mask
++      * and select the processor with the smallest ready count.
++      * Set the scheduler of the selected processor as target
++      * switchThread(target) migrates the current thread to 
++      * specified target's ready queue
++      */
++
++   } 
++
+ #if TESTING_ALWAYS_MIGRATE
+   if (!target) target = partner;
+ #else /* simple load balancing */
+@@ -143,3 +163,8 @@ void Scheduler::terminate() {
+   switchThread(nullptr);
+   unreachable();
+ }
++
++void Scheduler::yield(){
++  Runtime::RealLock rl;
++  preempt();
++}
+diff --git a/src/runtime/Scheduler.h b/src/runtime/Scheduler.h
+index bc86000..eae3fa8 100644
+--- a/src/runtime/Scheduler.h
++++ b/src/runtime/Scheduler.h
+@@ -34,7 +34,7 @@ class Scheduler {
+   volatile mword resumption;
+ 
+   Scheduler* partner;
+-
++  
+   template<typename... Args>
+   inline void switchThread(Scheduler* target, Args&... a);
+ 
+@@ -51,6 +51,7 @@ public:
+   void suspend(BasicLock& lk);
+   void suspend(BasicLock& lk1, BasicLock& lk2);
+   void terminate() __noreturn;
++  void yield();
+ };
+ 
+ #endif /* _Scheduler_h_ */
+diff --git a/src/runtime/Thread.h b/src/runtime/Thread.h
+index a09bb0e..953e1e2 100644
+--- a/src/runtime/Thread.h
++++ b/src/runtime/Thread.h
+@@ -33,6 +33,9 @@ class Thread : public EmbeddedList<Thread>::Link {
+ 
+   mword priority;           // scheduling priority
+   bool affinity;            // stick with scheduler
++  cpu_set_t affinityMask;	 	 // stick with multiple schedulers
++  // affinity mask of 0 means that the thread can be scheduled on any processor  
++
+   Scheduler* nextScheduler; // resume on same core (for now)
+ 
+   Runtime::MachContext ctx;
+@@ -47,7 +50,7 @@ protected:
+ 
+   Thread(vaddr sb, size_t ss) :
+     stackPointer(vaddr(this)), stackBottom(sb), stackSize(ss),
+-    priority(defPriority), affinity(false), nextScheduler(nullptr),
++    priority(defPriority), affinity(false), affinityMask(0), nextScheduler(nullptr),
+     state(Running), unblockInfo(nullptr) {}
+ 
+   // called directly when creating idle thread(s)
+@@ -81,6 +84,10 @@ public:
+   }
+ 
+   Thread* setPriority(mword p)      { priority = p; return this; }
++
++  void   setAffinityMask( cpu_set_t mask ) { affinityMask = mask; }
++  cpu_set_t  getAffinityMask() { return affinityMask; }
++
+   Thread* setAffinity(Scheduler* s) { affinity = (nextScheduler = s); return this; }
+   Scheduler* getAffinity() const    { return affinity ? nextScheduler : nullptr; }
+ 
+-- 
+1.9.1
+
+
+From 87519c8789909d56ac1e7e0c213145c4893d9a8e Mon Sep 17 00:00:00 2001
+From: priyaa <priyaa.mirra@gmail.com>
+Date: Thu, 25 Jun 2015 16:38:37 -0600
+Subject: [PATCH 2/2] Patch for get_core_count
+
+---
+ src/include/syscalls.h | 3 +++
+ src/kernel/syscalls.cc | 8 ++++++++
+ src/ulib/libKOS.cc     | 6 ++++++
+ 3 files changed, 17 insertions(+)
+
+diff --git a/src/include/syscalls.h b/src/include/syscalls.h
+index 9a9c429..4652b16 100644
+--- a/src/include/syscalls.h
++++ b/src/include/syscalls.h
+@@ -17,6 +17,8 @@ extern "C" int munmap(void* addr, size_t len);
+ 
+ extern "C" pid_t getcid();
+ 
++extern "C" long get_core_count();
++
+ extern "C" int privilege(void*, mword, mword, mword, mword);
+ 
+ namespace SyscallNum {
+@@ -28,6 +30,7 @@ enum : mword {
+   read,
+   write,
+   lseek,
++  get_core_count,
+   getpid,
+   getcid,
+   usleep,
+diff --git a/src/kernel/syscalls.cc b/src/kernel/syscalls.cc
+index 5a0bd06..763e731 100644
+--- a/src/kernel/syscalls.cc
++++ b/src/kernel/syscalls.cc
+@@ -21,6 +21,8 @@
+ #include "kernel/Process.h"
+ #include "world/Access.h"
+ #include "machine/Processor.h"
++#include "machine/Machine.h"
++
+ 
+ #include "syscalls.h"
+ #include "pthread.h"
+@@ -115,6 +117,11 @@ extern "C" off_t lseek(int fildes, off_t offset, int whence) {
+   return ret;
+ }
+ 
++/* I have added a system call here - Priyaa */
++extern "C" long get_core_count(){
++	return Machine::getProcessorCount();
++}
++
+ extern "C" pid_t getpid() {
+   return CurrProcess().getID();
+ }
+@@ -244,6 +251,7 @@ static const syscall_t syscalls[] = {
+   syscall_t(read),
+   syscall_t(write),
+   syscall_t(lseek),
++  syscall_t(get_core_count),
+   syscall_t(getpid),
+   syscall_t(getcid),
+   syscall_t(usleep),
+diff --git a/src/ulib/libKOS.cc b/src/ulib/libKOS.cc
+index 46c6bec..df25685 100644
+--- a/src/ulib/libKOS.cc
++++ b/src/ulib/libKOS.cc
+@@ -15,6 +15,7 @@
+     along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ ******************************************************************************/
+ #include "syscalls.h"
++#include "kostypes.h"
+ 
+ #include <string.h>
+ 
+@@ -70,6 +71,11 @@ extern "C" off_t lseek(int fildes, off_t offset, int whence) {
+   if (ret < 0) { *__errno() = -ret; return -1; } else return ret;
+ }
+ 
++/*added by Priyaa*/
++extern "C" long get_core_count() {
++  return syscallStub(SyscallNum::get_core_count);
++}
++
+ extern "C" pid_t getpid() {
+   return syscallStub(SyscallNum::getpid);
+ }
+-- 
+1.9.1
+
diff --git a/src/include/kostypes.h b/src/include/kostypes.h
index be993d3..650f684 100644
--- a/src/include/kostypes.h
+++ b/src/include/kostypes.h
@@ -26,12 +26,15 @@ typedef  int64_t sword;
 typedef mword vaddr;
 typedef mword paddr;
 
+typedef mword cpu_set_t;
+
 static const mword charbits = 8;
 static const mword bytebits = 8;
 
 typedef char  buf_t;
 typedef char* bufptr_t;
 typedef const char* cbufptr_t;
+
 #else
 #error unsupported architecture: only __x86_64__ supported at this time
 #endif
diff --git a/src/include/syscalls.h b/src/include/syscalls.h
index 388ffdd..d8ff6bc 100644
--- a/src/include/syscalls.h
+++ b/src/include/syscalls.h
@@ -1,5 +1,5 @@
 #ifndef _syscalls_h_
-#define _syscalls_h_ 1
+#define _syscalls_h_
 
 #include "kostypes.h"
 
@@ -17,21 +17,26 @@ extern "C" int munmap(void* addr, size_t len);
 
 extern "C" pid_t getcid();
 
+extern "C" long get_core_count();
+
 extern "C" int privilege(void*, mword, mword, mword, mword);
 
 extern "C" int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);
 extern "C" int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);
 
+
 namespace SyscallNum {
 
   enum : mword {
-  
     _exit = 0,
+      sched_setaffinity,
+      sched_getaffinity,
       open,
       close,
       read,
       write,
       lseek,
+      get_core_count,
       getpid,
       getcid,
       usleep,
@@ -47,8 +52,6 @@ namespace SyscallNum {
       semP,
       semV,
       privilege,
-      sched_setaffinity,
-      sched_getaffinity,
       _init_sig_handler,
       max
       };
diff --git a/src/kernel/#Kernel.cc# b/src/kernel/#Kernel.cc#
deleted file mode 100644
index 9b9c579..0000000
--- a/src/kernel/#Kernel.cc#
+++ /dev/null
@@ -1,86 +0,0 @@
-/******************************************************************************
-    Copyright © 2012-2015 Martin Karsten
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-******************************************************************************/
-#include "runtime/Thread.h"
-#include "kernel/AddressSpace.h"
-#include "kernel/Clock.h"
-#include "kernel/Output.h"
-#include "world/Access.h"
-#include "machine/Machine.h"
-#include "devices/Keyboard.h"
-
-#include "main/UserMain.h"
-
-AddressSpace kernelSpace(true); // AddressSpace.h
-volatile mword Clock::tick;     // Clock.h
-
-extern Keyboard keyboard;
-
-#if TESTING_KEYCODE_LOOP
-static void keybLoop() {
-  for (;;) {
-    Keyboard::KeyCode c = keyboard.read();
-    StdErr.print(' ', FmtHex(c));
-  }
-}
-#endif
-
-void kosMain() {
-  KOUT::outl("Welcome to KOS!", kendl);
-  auto iter = kernelFS.find("motb");
-  if (iter == kernelFS.end()) {
-    KOUT::outl("motb information not found");
-  } else {
-    FileAccess f(iter->second);
-    for (;;) {
-      char c;
-      if (f.read(&c, 1) == 0) break;
-      KOUT::out1(c);
-    }
-    KOUT::outl();
-  }
-#if TESTING_TIMER_TEST
-  StdErr.print(" timer test, 3 secs...");
-  for (int i = 0; i < 3; i++) {
-    Timeout::sleep(Clock::now() + 1000);
-    StdErr.print(' ', i+1);
-  }
-  StdErr.print(" done.", kendl);
-#endif
-#if TESTING_KEYCODE_LOOP
-  Thread* t = Thread::create()->setPriority(topPriority);
-  Machine::setAffinity(*t, 0);
-  t->start((ptr_t)keybLoop);
-#endif
-  Thread::create()->start((ptr_t)UserMain);
-#if TESTING_PING_LOOP
-  for (;;) {
-    Timeout::sleep(Clock::now() + 1000);
-    KOUT::outl("...ping...");
-  }
-#endif
-}
-
-extern "C" void kmain(mword magic, mword addr, mword idx)         __section(".boot.text");
-extern "C" void kmain(mword magic, mword addr, mword idx) {
-  if (magic == 0 && addr == 0xE85250D6) {
-    // low-level machine-dependent initialization on AP
-    Machine::initAP(idx);
-  } else {
-    // low-level machine-dependent initialization on BSP -> starts kosMain
-    Machine::initBSP(magic, addr, idx);
-  }
-}
diff --git a/src/kernel/#Process.cc# b/src/kernel/#Process.cc#
new file mode 100644
index 0000000..a0395cf
--- /dev/null
+++ b/src/kernel/#Process.cc#
@@ -0,0 +1,152 @@
+/******************************************************************************
+    Copyright © 2012-2015 Martin Karsten
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+******************************************************************************/
+#include "runtime/Scheduler.h"
+#include "runtime/Thread.h"
+#include "kernel/Process.h"
+#include "extern/elfio/elfio.hpp"
+
+void Process::invokeUser(funcvoid2_t func, ptr_t arg1, ptr_t arg2) {
+  UserThread* ut = reinterpret_cast<UserThread*>(LocalProcessor::getCurrThread());
+  KASSERT0(ut);
+  ut->stackSize = defaultUserStack;
+  ut->stackAddr = CurrAS().allocStack(ut->stackSize);
+  DBG::outl(DBG::Threads, "UThread start: ", FmtHex(ut), '/', FmtHex((ptr_t)func));
+  startUserCode(arg1, arg2, vaddr(ut), func, ut->stackAddr + ut->stackSize);
+  unreachable();
+}
+
+Process::~Process() {
+  DBG::outl(DBG::Threads, "Process delete: ", FmtHex(this));
+  for (size_t i = 0; i < ioHandles.currentIndex(); i += 1) {
+    Access* a = ioHandles.access(i);
+    if (a) kdelete(a);
+  }
+  for (size_t i = 0; i < semStore.currentIndex(); i += 1) {
+    if (semStore.valid(i)) kdelete(semStore.get(i));
+  }
+}
+
+void Process::exec(const string& fileName) {
+  KASSERT0(threadStore.empty());
+  AddressSpace& as = this->enter<true>();
+  auto iter = kernelFS.find(fileName);
+  KASSERT1(iter != kernelFS.end(), fileName.c_str())
+  RamFile& rf = iter->second;
+  ELFIO::elfio elfReader;
+  bool check = elfReader.load(fileName.c_str());
+  KASSERT0(check);
+  KASSERT1(elfReader.get_class() == ELFCLASS64, elfReader.get_class());
+
+  vaddr currBreak = 0;
+  for (int i = 0; i < elfReader.segments.size(); ++i) {
+    const ELFIO::segment* pseg = elfReader.segments[i];
+    if (pseg->get_type() != PT_LOAD) continue;  // not a loadable segment
+
+    KASSERTN(pseg->get_file_offset() + pseg->get_file_size() <= rf.size, FmtHex(pseg->get_file_offset()), ' ', FmtHex(pseg->get_file_size()), ' ', FmtHex(rf.size));
+    KASSERTN(pseg->get_memory_size() >= pseg->get_file_size(), FmtHex(pseg->get_file_size()), ' ', FmtHex(pseg->get_memory_size()));
+    paddr pma = rf.pma + pseg->get_file_offset();
+    paddr apma = align_down(pma, pagesize<1>());
+    vaddr vma = pseg->get_virtual_address();
+    vaddr avma = align_down(vma, pagesize<1>());
+    KASSERTN(vma - avma == pma - apma, FmtHex(vma), ' ', FmtHex(pma));
+    vaddr fend = vma + pseg->get_file_size();
+    vaddr afend = align_up(fend, pagesize<1>());
+    vaddr mend = vma + pseg->get_memory_size();
+    vaddr amend = align_up(mend, pagesize<1>());
+
+    // If .rodata and .text are in the same elf segment and small enough to
+    // fit into a single page, then .rodata ends up being marked executable.
+    PageType pageType = (pseg->get_flags() & PF_W) ? Data :
+      (pseg->get_flags() & PF_X) ? Code : RoData;
+
+    DBG::outl(DBG::Process,
+      pageType == Data ? "data" : pageType == Code ? "code" : "ro",
+      " segment: ", FmtHex(vma), '-', FmtHex(fend));
+    mapDirect<1>(apma, avma, afend - avma, pageType);
+
+    if (mend > fend) {
+      DBG::outl(DBG::Process, "bss: ", FmtHex(fend), '-', FmtHex(mend));
+      if (amend > afend) allocDirect<1>(afend, amend - afend, Data);
+      memset((void*)fend, 0, mend - fend);
+    }
+    if (mend > currBreak) currBreak = mend;
+  }
+
+  initUser(currBreak);
+  ptr_t entry = (ptr_t)elfReader.get_entry();
+  DBG::outl(DBG::Process, "entry: ", FmtHex(entry));
+  createThread((funcvoid2_t)entry, (funcvoid1_t)nullptr, nullptr);
+  as.enter<true>();
+}
+
+// detach all -> cancel all
+void Process::exit() {
+  UserThread* ut = reinterpret_cast<UserThread*>(LocalProcessor::getCurrThread());
+  KASSERT0(ut);
+  DBG::outl(DBG::Threads, "Process exit: ", FmtHex(ut));
+  threadLock.acquire();
+  for (mword i = 0; i < threadStore.currentIndex(); i += 1) {
+    if fastpath(threadStore.valid(i) && threadStore.get(i) != ut)	{
+      threadStore.get(i)->cancel();
+    }
+  }
+  threadLock.release();
+  LocalProcessor::getScheduler()->terminate();
+}
+
+mword Process::createThread(funcvoid2_t wrapper, funcvoid1_t func, ptr_t data) {
+  UserThread* ut = UserThread::create();
+  KASSERT0(ut);
+  threadLock.acquire();
+  ut->idx = threadStore.put(ut);
+  DBG::outl(DBG::Threads, "UThread create: ", FmtHex(ut), '/', ut->idx);
+  ut->start((ptr_t)invokeUser, (ptr_t)wrapper, (ptr_t)func, data);
+  threadLock.release();
+  return ut->idx;
+}
+
+void Process::exitThread(ptr_t result) {
+  UserThread* ut = reinterpret_cast<UserThread*>(LocalProcessor::getCurrThread());
+  KASSERT0(ut);
+  DBG::outl(DBG::Threads, "UThread exit: ", FmtHex(ut), '/', ut->idx);
+  releaseStack(ut->stackAddr, ut->stackSize);
+  threadLock.acquire();
+  if (threadStore.size() > 1) ut->post(result, threadLock);
+  else threadLock.release();
+  LocalProcessor::getScheduler()->terminate();
+}
+
+int Process::joinThread(mword idx, ptr_t& result) {
+  DBG::outl(DBG::Threads, "UThread join: ", idx);
+  threadLock.acquire();
+  if (!threadStore.valid(idx)) {
+    threadLock.release();
+    return -ESRCH;
+  }
+  if (!threadStore.get(idx)->join(result, threadLock)) {
+    threadLock.release();
+    return -EINVAL;
+  }
+  return 0;
+}
+
+bool Process::destroyThread(Thread& t) {
+  UserThread& ut = reinterpret_cast<UserThread&>(t);
+  ScopedLock<> sl(threadLock);
+  threadStore.remove(ut.idx);
+  return threadStore.empty();
+}
diff --git a/src/kernel/Kernel.cc b/src/kernel/Kernel.cc
index 5a64aea..c7ee795 100644
--- a/src/kernel/Kernel.cc
+++ b/src/kernel/Kernel.cc
@@ -69,7 +69,7 @@ void kosMain() {
 #if TESTING_PING_LOOP
   for (;;) {
     Timeout::sleep(Clock::now() + 1000);
-    KOUT::outl("...ping...");
+    //KOUT::outl("...ping...");
   }
 #endif
 }
diff --git a/src/kernel/syscalls.cc b/src/kernel/syscalls.cc
index f354b3b..dc4ca9c 100644
--- a/src/kernel/syscalls.cc
+++ b/src/kernel/syscalls.cc
@@ -21,21 +21,15 @@
 #include "kernel/Process.h"
 #include "world/Access.h"
 #include "machine/Processor.h"
+#include "machine/Machine.h"
+
 
 #include "syscalls.h"
 #include "pthread.h"
 
-/******* libc functions *******/
 
-extern "C" int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
-{
-  
-}
+/******* libc functions *******/
 
-extern "C" int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
-{
-  
-}
 
 
 
@@ -51,6 +45,57 @@ extern "C" void abort() {
   unreachable();
 }
 
+
+extern "C" int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
+{
+
+
+  if(pid == 0)
+    {
+      if(cpusetsize > sizeof(cpu_set_t) || *mask > get_core_count()) //If the core count is too high
+	{
+	  return -1; //EINVAL
+	}
+      else
+	{
+	  Runtime::getCurrThread()->setAffinityMask(*mask);
+
+	  LocalProcessor::getScheduler()->yield();
+	  return 0;
+	}
+      
+      //no error 
+    }
+  else
+    {
+      return -1; //EPERM
+    }
+
+      
+   
+}
+
+extern "C" int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
+{
+
+  int getMask;
+  if(pid == 0)
+    {
+
+      getMask = Runtime::getCurrThread()->getAffinityMask(); //get the mask
+      
+      
+      return getMask;//Runtime::getCurrThread()->getAffinityMask();
+       
+    }
+  else
+    {
+
+      return -1;
+    }
+}
+
+
 extern "C" void free(void* ptr) { MemoryManager::legacy_free(ptr); }
 extern "C" void _free_r(_reent* r, void* ptr) { free(ptr); }
 extern "C" void* malloc(size_t size) { return MemoryManager::legacy_malloc(size); }
@@ -127,6 +172,11 @@ extern "C" off_t lseek(int fildes, off_t offset, int whence) {
   return ret;
 }
 
+/* I have added a system call here - Priyaa */
+extern "C" long get_core_count(){
+	return Machine::getProcessorCount();
+}
+
 extern "C" pid_t getpid() {
   return CurrProcess().getID();
 }
@@ -251,11 +301,14 @@ void* __dso_handle = nullptr;
 typedef ssize_t (*syscall_t)(mword a1, mword a2, mword a3, mword a4, mword a5);
 static const syscall_t syscalls[] = {
   syscall_t(_exit),
+  syscall_t(sched_setaffinity),
+  syscall_t(sched_getaffinity),
   syscall_t(open),
   syscall_t(close),
   syscall_t(read),
   syscall_t(write),
   syscall_t(lseek),
+  syscall_t(get_core_count),
   syscall_t(getpid),
   syscall_t(getcid),
   syscall_t(usleep),
@@ -271,8 +324,6 @@ static const syscall_t syscalls[] = {
   syscall_t(semP),
   syscall_t(semV),
   syscall_t(privilege),
-  syscall_t(sched_setaffinity),
-  syscall_t(sched_getaffinity),
   syscall_t(_init_sig_handler)
 };
 
diff --git a/src/machine/#Machine.cc# b/src/machine/#Machine.cc#
new file mode 100644
index 0000000..08e4cce
--- /dev/null
+++ b/src/machine/#Machine.cc#
@@ -0,0 +1,1079 @@
+/******************************************************************************
+    Copyright © 2012-2015 Martin Karsten
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+******************************************************************************/
+#include "runtime/Scheduler.h"
+#include "runtime/Thread.h"
+#include "kernel/AddressSpace.h"
+#include "kernel/Clock.h"
+#include "kernel/FrameManager.h"
+#include "kernel/MemoryManager.h"
+#include "kernel/Multiboot.h"
+#include "kernel/Process.h"
+#include "machine/asmdecl.h"
+#include "machine/APIC.h"
+#include "machine/Machine.h"
+#include "machine/Processor.h"
+#include "machine/Paging.h"
+#include "devices/Keyboard.h"
+#include "devices/PCI.h"
+#include "devices/PIT.h"
+#include "devices/RTC.h"
+#include "devices/Screen.h"
+#include "devices/Serial.h"
+#include "gdb/Gdb.h"
+#include "syscalls.h"
+
+#include "machine/ACPI.h"
+
+#include <list>
+#include <map>
+
+// simple direct declarations in lieu of more header files
+extern void initCdiDrivers();
+extern bool findCdiDriver(const PCIDevice&);
+extern void lwip_init_tcpip();
+extern void kosMain();
+
+// check various assumptions about data type sizes
+static_assert(sizeof(uint64_t) == sizeof(mword), "mword != uint64_t" );
+static_assert(sizeof(size_t) == sizeof(mword), "mword != size_t");
+static_assert(sizeof(ptr_t) == sizeof(mword), "mword != ptr_t");
+static_assert(sizeof(APIC) == 0x400, "sizeof(APIC) != 0x400" );
+static_assert(sizeof(APIC) <= pagesize<1>(), "sizeof(APIC) <= pagesize<1>()" );
+static_assert(sizeof(InterruptDescriptor) == 2 * sizeof(mword), "sizeof(InterruptDescriptor) != 2 * sizeof(mword)" );
+static_assert(sizeof(SegmentDescriptor) == sizeof(mword), "sizeof(SegmentDescriptor) != sizeof(mword)" );
+
+// pointers to 16-bit boot code location from boot.S
+extern const char boot16Begin, boot16End;
+
+// symbols set during linking, see linker.ld
+extern const char __KernelBoot,  __KernelBootEnd;
+extern const char __KernelCtors, __KernelCtorsEnd;
+extern const char __KernelCode,  __KernelCodeEnd;
+extern const char __KernelRO,    __KernelRO_End;
+extern const char __KernelData,  __KernelDataEnd;
+extern const char __KernelBss,   __KernelBssEnd;
+extern const char __MultibootHdr;
+
+// various helpers during bootstrap
+static Processor dummyProc    __section(".boot.data"); // dummy processor object
+static vaddr kernelEnd        __section(".boot.data"); // passed from initBSP to bootCleanup
+static volatile mword apIndex __section(".boot.data"); // enumerate APs
+static paddr pml4addr         __section(".boot.data"); // root of kernel AS
+
+// global frame manager objects
+static FrameManager frameManager;
+
+// global device objects
+Keyboard keyboard;
+static RTC rtc;
+static PIT pit;
+
+// interrupt descriptor tables
+static const unsigned int maxIDT = 256;
+static InterruptDescriptor idt[maxIDT]                __aligned(pagesize<1>());
+
+// CPU information
+mword Machine::processorCount = 0;
+static Processor* processorTable = nullptr;
+static Scheduler* schedulerTable = nullptr;
+static mword bspIndex = ~mword(0);
+static mword bspApicID = ~mword(0);
+
+// simple IPI test during bootstrap
+void (*tipiHandler)(void) = nullptr;
+static volatile bool tipiTest __section(".boot.data");
+static void tipiReceiver()    __section(".boot.text");
+static void tipiReceiver() {
+  KERR::out1(" TIPI ");
+  tipiTest = true;
+}
+
+// IRQ handling
+static const int MaxIrqCount = 192;
+struct IrqInfo {
+  paddr    ioApicAddr;
+  uint8_t  ioApicIrq;
+  uint8_t  globalIrq;
+  uint16_t overrideFlags;
+  typedef pair<funcvoid1_t,ptr_t> Handler;
+  list<Handler,KernelAllocator<Handler>> handlers;
+} irqTable[MaxIrqCount];
+static Bitmap<MaxIrqCount> irqMask;     // IRQ bitmap
+static Semaphore asyncIrqSem;
+
+
+
+
+Scheduler* Machine::getScheduler(mword core)
+{
+  
+  return processorTable[core].getSchedulerProcess();
+
+}
+
+// init routine for APs: on boot stack and using identity paging
+void Machine::initAP(mword idx) {
+  KASSERT1(idx == apIndex, idx);
+  processorTable[apIndex].init(pml4addr, idt, sizeof(idt), initAP2);
+}
+
+// on proper stack, processor initialized
+void Machine::initAP2() {
+  startGdbCpu(apIndex);             // tell GDB that this CPU is running
+  apIndex = bspIndex;               // sync with BSP
+  DBG::outl(DBG::Boot, "Enabling AP interrupts...");
+  LocalProcessor::initInterrupts(false); // enable interrupts (off boot stack)
+  DBG::outl(DBG::Boot, "Finishing AP boot thread...");
+  LocalProcessor::getScheduler()->terminate(); // idle thread takes over
+}
+
+// init routine for BSP, on boot stack and identity paging
+void Machine::initBSP(mword magic, vaddr mbiAddr, mword idx) {
+
+  // initialize bss
+  memset((char*)&__KernelBss, 0, &__KernelBssEnd - &__KernelBss);
+
+  // static memory to back temporary heap during bootstrap
+  static buf_t bootHeap[bootHeapSize]                  __section(".boot.data");
+
+  // create temporary boot heap, so that ctors & RegionMap can use malloc/free
+  MemoryManager::init0( (vaddr)bootHeap, sizeof(bootHeap) );
+
+  // set up dummy processor for lock counter -> output/malloc uses spinlock
+  dummyProc.install();
+
+  // initialize multiboot & debugging: no debug options before this point!
+  vaddr mbiEnd = Multiboot::init(magic, mbiAddr);
+  // determine end addresses of kernel overall (including multiboot & modules)
+  kernelEnd = align_up(mbiEnd, kernelps) + kernelBase;
+
+  // initialize basic devices -> needed for printing
+  if (!Screen::init(kernelBase)) Reboot();        // no identity mapping later
+  DebugDevice::init();                            // init qemu debug device
+  SerialDevice::init(DBG::test(DBG::GDBEnable));  // must come after multiboot/debug init
+
+  // call global constructors: can use temporary dynamic memory
+  // %rbx is callee-saved; explicitly protect all caller-saved registers
+  for ( const char* x = &__KernelCtors; x != &__KernelCtorsEnd; x += sizeof(char*)) {
+    asm volatile( "call *(%0)" : : "b"(x) : "memory", "cc", "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11" );
+  }
+
+  // can print now: install global IDT entries - the earlier the better...
+  setupIDTable();
+
+  // check processor, set paging bits, print results
+  dummyProc.check(true);
+
+  // print all MBI info, re-initialize debugging to print debug options
+  Multiboot::init2();
+
+  // double-check that BSP received index 0
+  KASSERT1(idx == 0, idx);
+
+  // print boot memory information
+  DBG::outl(DBG::Boot, "*********** MEM INFO ***********");
+  DBG::outl(DBG::Boot, "Boot16:    ", FmtHex(&boot16Begin),  " - ", FmtHex(&boot16End), " -> ", FmtHex(BOOTAP16));
+  DBG::outl(DBG::Boot, "PageTbls:  ", FmtHex(Paging::ptprefix<1>()), " - ", FmtHex(Paging::ptend()));
+  DBG::outl(DBG::Boot, "Kernel:    ", FmtHex(kernelBase),    " - ", FmtHex(kernelEnd));
+  DBG::outl(DBG::Boot, "Boot Seg:  ", FmtHex(&__KernelBoot), " - ", FmtHex(&__KernelBootEnd));
+  DBG::outl(DBG::Boot, "Code Seg:  ", FmtHex(&__KernelCode), " - ", FmtHex(&__KernelCodeEnd));
+  DBG::outl(DBG::Boot, "RO Seg:    ", FmtHex(&__KernelRO),   " - ", FmtHex(&__KernelRO_End));
+  DBG::outl(DBG::Boot, "Data Seg:  ", FmtHex(&__KernelData), " - ", FmtHex(&__KernelDataEnd));
+  DBG::outl(DBG::Boot, "Bss Seg:   ", FmtHex(&__KernelBss),  " - ", FmtHex(&__KernelBssEnd));
+  DBG::outl(DBG::Boot, "MB/MBI:    ", FmtHex(&__MultibootHdr + kernelBase), " / ", FmtHex(mbiAddr + kernelBase));
+  DBG::outl(DBG::Boot, "Vid/APIC:  ", FmtHex(videoAddr), " / ", FmtHex(apicAddr));
+
+  DBG::outl(DBG::Boot, "*********** BOOTING ************");
+
+  // collect available and used memory
+  RegionSet<Region<paddr>> memtmp, mem;
+  Multiboot::getMemory( memtmp );
+  for (auto it = memtmp.begin(); it != memtmp.end(); ) {
+    mem.insert( Region<paddr>(align_up(it->start, pagesize<1>()), align_down(it->end, pagesize<1>())) );
+    it = memtmp.erase(it);
+  }
+  bool check = mem.remove( Region<paddr>(vaddr(&__KernelBoot) - kernelBase, kernelEnd - kernelBase) );
+  KASSERT0(check);
+  size_t boot16Size = align_up( size_t(&boot16End - &boot16Begin), pagesize<1>());
+  check = mem.remove( Region<paddr>(BOOTAP16, BOOTAP16 + boot16Size) );
+  KASSERT0(check);
+  KASSERT0(!mem.empty());
+
+  // copy boot code segment -> easy with identiy mapping
+  memcpy( bufptr_t(BOOTAP16), &boot16Begin, boot16Size );
+
+  // bootstrap paging -> afterwards: identity mapping is gone
+  pml4addr = Paging::bootstrap(kernelEnd);
+  Multiboot::remap(kernelBase);
+
+  // allocate and map memory for frame manager <- need paging bootstrapped
+  paddr endphysmem = (--mem.end())->end;
+  size_t fmStart = kerneltop - FrameManager::getSize( endphysmem );
+  vaddr initStart = kerneltop;
+  while ( initStart + bootHeapSize > fmStart ) { // ensure leftover for kernel memory
+    paddr start = mem.retrieve(kernelps);
+    KASSERT0(start != topaddr);
+    initStart -= kernelps;
+    // frameManager useless at this point, but not needed - page tables bootstrap
+    bool check = Paging::map<kernelpl,true>(initStart, start, Paging::KernelData, frameManager);
+    KASSERT1(check, initStart);
+  }
+
+  // re-init kernel heap, discard boot heap <- use leftover from FM init
+  MemoryManager::reinit(initStart, fmStart - initStart);
+
+  // rerun all global constructors: can now use proper dynamic memory
+  // %rbx is callee-saved; explicitly protect all caller-saved registers
+  DBG::out1(DBG::Boot, "constructors:");
+  for ( const char* x = &__KernelCtors; x != &__KernelCtorsEnd; x += sizeof(char*)) {
+    DBG::out1(DBG::Boot, ' ', FmtHex(x));
+    asm volatile( "call *(%0)" : : "b"(x) : "memory", "cc", "rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11" );
+  }
+  DBG::outl(DBG::Boot);
+
+  // initialize frame manager <- need dynamic memory for internal container
+  frameManager.init( (bufptr_t)fmStart, endphysmem );
+  for ( auto it = mem.begin(); it != mem.end(); ++it ) {
+    frameManager.releaseRegion( it->start, it->end - it->start );
+  }
+  DBG::outl(DBG::Boot, "FM/init: ", frameManager);
+
+  // set up top-level kernel page tables (for later AS cloning) <- need FM
+  Paging::bootstrap2(frameManager);
+  DBG::outl(DBG::Boot, "Paging & FM initialized");
+
+  // set frame manager in dummy processor -> needed for page mappings
+  dummyProc.frameManager = &frameManager;
+
+  // init kernel address space <- need dynamic memory for internal container
+  kernelSpace.initKernel(kernelbot, initStart, pml4addr);
+  DBG::outl(DBG::Boot, "AS/init: ", kernelSpace);
+
+  // parse ACPI tables: find/initialize CPUs, APICs, IOAPICs
+  map<uint32_t,uint32_t> apicMap;
+  map<uint32_t,paddr> ioApicMap;
+  map<uint8_t,pair<uint32_t,uint16_t>> ioOverrideMap;
+  paddr rsdp = Multiboot::getRSDP() - kernelBase;
+  paddr apicPhysAddr = initACPI(rsdp, apicMap, ioApicMap, ioOverrideMap);
+
+  // process IOAPIC/IRQ information -> mask all IOAPIC interrupts for now
+  for (const pair<uint32_t,paddr>&iop : ioApicMap) {
+    kernelSpace.mapDirect<1>(iop.second, ioApicAddr, pagesize<1>(), Paging::MMapIO);
+    mword rdr = MappedIOAPIC()->getRedirects() + 1;
+    for (mword x = 0; x < rdr; x += 1 ) {
+      MappedIOAPIC()->maskIRQ(x);
+      mword irqnum = iop.first + x;
+      KASSERT1(irqnum < MaxIrqCount, irqnum);
+      irqTable[irqnum].ioApicAddr = iop.second;
+      irqTable[irqnum].ioApicIrq  = x;
+      if (ioOverrideMap.count(irqnum) > 0) {
+        pair<uint32_t,uint16_t>& override = ioOverrideMap.at(irqnum);
+        irqTable[irqnum].globalIrq     = override.first;
+        irqTable[irqnum].overrideFlags = override.second;
+      } else {
+        irqTable[irqnum].globalIrq     = irqnum;
+      }
+    }
+    kernelSpace.unmapDirect<1>(ioApicAddr, pagesize<1>());
+  }
+
+  // NOTE: could use broadcast and ticket lock sequencing in Machine::initBSP2()
+  // determine processorCount and create processorTable
+  KASSERT0(apicMap.size());
+  processorCount = apicMap.size();
+  processorTable = knewN<Processor>(processorCount);
+  schedulerTable = knewN<Scheduler>(processorCount);
+  mword coreIdx = 0;
+  for (const pair<uint32_t,uint32_t>& ap : apicMap) {
+    DBG::outl( DBG::Scheduler, "Scheduler ", coreIdx, " at ", FmtHex(schedulerTable + coreIdx));
+    schedulerTable[coreIdx].setPartner(schedulerTable[(coreIdx + 1) % processorCount]);
+    processorTable[coreIdx].setup(kernelSpace, kernelSpace.initProcessor(),
+      schedulerTable[coreIdx], frameManager, coreIdx, ap.second, ap.first);
+    coreIdx += 1;
+  }
+
+  // map APIC page, use APIC ID to determine bspIndex
+  kernelSpace.mapDirect<1>(apicPhysAddr, apicAddr, pagesize<1>(), Paging::MMapIO);
+  bspApicID = MappedAPIC()->getID();
+  for (mword i = 0; i < processorCount; i += 1) {
+    if (processorTable[i].apicID == bspApicID) {
+      bspIndex = i;
+      break;
+    }
+  }
+  DBG::outl(DBG::Boot, "CPUs: ", processorCount, '/', bspIndex, '/', bspApicID);
+  KASSERT0(bspIndex != ~mword(0));
+
+  // init and install processor object (need bspIndex) -> start main/idle loop
+  processorTable[bspIndex].init(pml4addr, idt, sizeof(idt), bootMain);
+}
+
+// on proper stack, processor initialized
+void Machine::initBSP2() {
+  DBG::outl(DBG::Boot, "********** NEW STACK ***********");
+  DBG::outl(DBG::Boot, "BSP: ", LocalProcessor::getIndex(), '/', LocalProcessor::getSystemID(), '/', LocalProcessor::getApicID());
+
+  // initialize GDB object -> after ACPI init & IDT installed
+  initGdb(bspIndex);
+
+  DBG::outl(DBG::Boot, "Initializing basic devices...");
+  // init RTC timer; used for preemption & sleeping
+  rtc.init();
+  // init PIT timer; used for waiting
+  pit.init();
+  // init keyboard; must init RTC first (HW req)?
+  keyboard.init();
+
+  DBG::outl(DBG::Boot, "********** MULTI CORE **********");
+
+  // enable interrupts (off boot stack); needed for timer waiting
+  DBG::outl(DBG::Boot, "Enabling BSP interrupts...");
+  LocalProcessor::initInterrupts(true);
+
+  // send test IPI to self <- reception needs interrupts enabled
+  tipiTest = false;
+  tipiHandler = tipiReceiver;
+  sendIPI(bspIndex, APIC::TestIPI);
+  while (!tipiTest) CPU::Pause();
+
+  // NOTE: could use broadcast and ticket lock sequencing
+  // start up APs one by one (on boot stack): APs go into long mode and halt
+  StdOut.print("AP init (", FmtHex(BOOTAP16 / 0x1000), "):");
+  for (mword idx = 0; idx < processorCount; idx += 1) {
+    if (idx != bspIndex) {
+      apIndex = idx;
+      for (;;) {
+        mword ai = processorTable[idx].apicID;
+        StdOut.print(' ', ai);
+        MappedAPIC()->sendInitIPI(ai);
+        StdOut.print('I');
+        Clock::wait(100);                // wait for HW init
+        MappedAPIC()->sendInitDeassertIPI(ai);
+        StdOut.print('D');
+        Clock::wait(100);                // wait for HW init
+        for (int i = 0; i < 10; i += 1) {
+          MappedAPIC()->sendStartupIPI(ai, BOOTAP16 / 0x1000);
+          StdOut.print('S');
+          for (int j = 0; j < 1000; j += 1) {
+            Clock::wait(1);
+            if (apIndex != idx) goto apDone;
+          }
+        }
+      }
+apDone:
+      StdOut.print('|', idx);
+    }
+  }
+  StdOut.print(kendl);
+
+  DBG::outl(DBG::Boot, "Building kernel filesystem...");
+  // initialize kernel file system with boot modules
+  Multiboot::readModules(kernelBase);
+
+  // more info from ACPI; could find IOAPIC interrupt pins for PCI devices
+  initACPI2(); // needs "current thread"
+
+  // initialize CDI drivers
+  initCdiDrivers();
+  DBG::outl(DBG::Boot, "CDI drivers initialized.");
+
+  // probe for PCI devices
+  list<PCIDevice> pciDevList;
+  PCI::sanityCheck();
+  PCI::checkAllBuses(pciDevList);
+
+  // initialize TCP/IP stack - needed to start network devices
+  DBG::outl(DBG::Boot, "Starting network subsystem...");
+  lwip_init_tcpip();
+
+  DBG::outl(DBG::Boot, "Starting CDI devices...");
+  // find and install CDI drivers for PCI devices - need interrupts for sleep
+  for (const PCIDevice& pd : pciDevList) findCdiDriver(pd);
+
+  // start irq thread after cdi init -> avoid interference from device irqs
+  DBG::outl(DBG::Boot, "Creating IRQ thread...");
+  Thread::create()->setPriority(topPriority)->setAffinity(processorTable[0].scheduler)->start((ptr_t)asyncIrqLoop);
+}
+
+void Machine::bootCleanup() {
+  DBG::outl(DBG::Boot, "********* MEMORY CLEANUP *********");
+
+  // free AP boot code
+  frameManager.releaseRegion(BOOTAP16, pagesize<1>());
+  DBG::outl(DBG::Boot, "FM/free16:", frameManager);
+
+#if 0
+  // unmap & free multiboot memory
+  for ( vaddr x = kernelBase + vaddr(&__MultibootHdr); x < kernelEnd; x += kernelps ) {
+    Paging::unmap<kernelpl>(x);
+    frameManager.releaseRegion(x - kernelBase, kernelps );
+  }
+  DBG::outl(DBG::Boot, "FM/mbi:", frameManager);
+#endif
+
+  // remap screen page high, before low memory paging entries disappear
+  kernelSpace.mapDirect<1>(Paging::vtop(Screen::getAddress()), videoAddr, pagesize<1>(), Paging::MMapIO);
+  Screen::setAddress(videoAddr);
+
+  // unmap & free kernel boot memory
+  Paging::unmap<kernelpl>(kernelBase);
+  frameManager.releaseRegion( vaddr(&__KernelBoot) - kernelBase, kernelBase + kernelps - vaddr(&__KernelBoot) );
+  for ( vaddr x = kernelBase + kernelps; x < vaddr(&__KernelCode); x += kernelps / 2 ) {
+    Paging::unmap<kernelpl>(x);
+    frameManager.releaseRegion(x - kernelBase, kernelps);
+  }
+
+  // VM addresses from above are not reused, thus no TLB invalidation needed
+  DBG::outl(DBG::Boot, "FM/boot:", frameManager);
+  DBG::outl(DBG::Boot, "AS/boot: ", kernelSpace);
+}
+
+void Machine::bootMain() {
+  Machine::initBSP2();
+  Machine::bootCleanup();
+  Thread::create()->start((ptr_t)kosMain);
+  LocalProcessor::getScheduler()->terminate(); // explicitly terminate boot thread
+}
+
+void Machine::setAffinity(Thread& t, mword idx) {
+  KASSERT1(idx < processorCount, idx);
+  t.setAffinity(processorTable[idx].scheduler);
+}
+
+void Machine::sendIPI(mword idx, uint8_t vec) {
+  MappedAPIC()->sendIPI(processorTable[idx].apicID, vec);
+}
+
+void Machine::sendWakeIPI(Scheduler* scheduler) {
+  MappedAPIC()->sendIPI(processorTable[scheduler - schedulerTable].apicID, APIC::WakeIPI);
+}
+
+void Machine::rrPreemptIPI(mword tick) {
+  sendIPI(processorTable[tick % processorCount].apicID, APIC::PreemptIPI);
+}
+
+/*********************** IRQ / Exception Handling Code ***********************/
+
+void Machine::asyncIrqLoop() {
+  for (;;) {
+    asyncIrqSem.P();
+    for (;;) {
+      mword idx = irqMask.findset();
+      if slowpath(idx >= MaxIrqCount) break;
+#if TESTING_REPORT_INTERRUPTS
+      StdErr.out1(" AH:", FmtHex(idx));
+#endif
+      irqMask.clear<true>(idx);
+      for (IrqInfo::Handler f : irqTable[idx].handlers) f.first(f.second);
+    }
+  }
+};
+
+void Machine::mapIrq(mword irq, mword vector) {
+  static SpinLock ioapicLock;
+  mword irqmod = irqTable[irq].globalIrq;
+  DBG::outl(DBG::Basic, "IRQ mapping: ", FmtHex(irq), '/', FmtHex(irqTable[irqmod].ioApicIrq), " -> ", FmtHex(vector));
+  kernelSpace.mapDirect<1>(irqTable[irqmod].ioApicAddr, ioApicAddr, pagesize<1>(), AddressSpace::MMapIO);
+  if (vector) {
+    ScopedLock<> sl(ioapicLock);
+    // TODO: program IOAPIC with polarity/trigger (ACPI flags), if necessary
+    MappedIOAPIC()->mapIRQ( irqTable[irqmod].ioApicIrq, vector, bspApicID );
+  } else {
+    ScopedLock<> sl(ioapicLock);
+    MappedIOAPIC()->maskIRQ( irqTable[irqmod].ioApicIrq );
+  }
+  kernelSpace.unmapDirect<1>(ioApicAddr, pagesize<1>());
+}
+
+void Machine::registerIrqSync(mword irq, mword vector) {
+  ScopedLock<LocalProcessor> sl;
+  KASSERT0(irqTable[irq].handlers.empty());
+  mapIrq(irq, vector);
+}
+
+void Machine::registerIrqAsync(mword irq, funcvoid1_t handler, ptr_t ctx) {
+  mword vector = irq + 0x20;
+  DBG::outl(DBG::Basic, "register async IRQ handler: ", FmtHex(ptr_t(handler)), " for irq/vector ", FmtHex(irq), '/', FmtHex(vector));
+  ScopedLock<LocalProcessor> sl;
+  if (irqTable[irq].handlers.empty()) mapIrq(irq, vector);
+  irqTable[irq].handlers.push_back( {handler, ctx} );
+}
+
+void Machine::deregisterIrqAsync(mword irq, funcvoid1_t handler) {
+  DBG::outl(DBG::Basic, "deregister async IRQ handler: ", FmtHex(ptr_t(handler)), " for irq ", FmtHex(irq));
+  ScopedLock<LocalProcessor> sl;
+  auto it = irqTable[irq].handlers.begin();
+  for ( ; it != irqTable[irq].handlers.end(); ++it ) {
+    if (it->first == handler) {
+      irqTable[irq].handlers.erase(it);
+  break;
+    }
+  }
+  if (irqTable[irq].handlers.empty()) mapIrq(irq, 0);
+}
+
+void Machine::setupIDT(uint32_t number, paddr address, uint32_t ist) {
+  KASSERT1(number < maxIDT, number);
+  idt[number].Offset00 = (address & 0x000000000000FFFF);
+  idt[number].Offset16 = (address & 0x00000000FFFF0000) >> 16;
+  idt[number].Offset32 = (address & 0xFFFFFFFF00000000) >> 32;
+  idt[number].SegmentSelector = Processor::kernCS * sizeof(SegmentDescriptor);
+  idt[number].IST = ist;
+  idt[number].Type = 0x0E; // 64-bit interrupt gate (trap gate does not disable interrupts)
+  idt[number].P = 1;
+}
+
+void Machine::setupIDTable() {
+  KASSERT0(!CPU::interruptsEnabled());
+
+  for (size_t i = 0; i < MaxIrqCount; i += 1) {
+    irqTable[i].ioApicAddr    = 0;
+    irqTable[i].ioApicIrq     = 0;
+    irqTable[i].globalIrq     = i; 
+    irqTable[i].overrideFlags = 0;
+  }
+
+  memset(idt, 0, sizeof(idt));
+
+  // first 32 vectors are architectural or reserved
+  setupIDT(0x00, (vaddr)&isr_wrapper_0x00);
+  setupIDT(0x01, (vaddr)&isr_wrapper_0x01);
+  setupIDT(0x02, (vaddr)&isr_wrapper_0x02, Processor::nmiIST);
+  setupIDT(0x03, (vaddr)&isr_wrapper_0x03);
+  setupIDT(0x04, (vaddr)&isr_wrapper_0x04);
+  setupIDT(0x05, (vaddr)&isr_wrapper_0x05);
+  setupIDT(0x06, (vaddr)&isr_wrapper_0x06);
+  setupIDT(0x07, (vaddr)&isr_wrapper_0x07);
+  setupIDT(0x08, (vaddr)&isr_wrapper_0x08, Processor::dbfIST); // double fault
+  setupIDT(0x09, (vaddr)&isr_wrapper_0x09);
+  setupIDT(0x0a, (vaddr)&isr_wrapper_0x0a);
+  setupIDT(0x0b, (vaddr)&isr_wrapper_0x0b);
+  setupIDT(0x0c, (vaddr)&isr_wrapper_0x0c, Processor::stfIST); // stack fault
+  setupIDT(0x0d, (vaddr)&isr_wrapper_0x0d); // general protection fault
+  setupIDT(0x0e, (vaddr)&isr_wrapper_0x0e, Processor::pgfIST); // page fault
+  setupIDT(0x0f, (vaddr)&isr_wrapper_0x0f);
+  setupIDT(0x10, (vaddr)&isr_wrapper_0x10);
+  setupIDT(0x11, (vaddr)&isr_wrapper_0x11);
+  setupIDT(0x12, (vaddr)&isr_wrapper_0x12);
+  setupIDT(0x13, (vaddr)&isr_wrapper_0x13);
+  setupIDT(0x14, (vaddr)&isr_wrapper_0x14);
+  setupIDT(0x15, (vaddr)&isr_wrapper_0x15);
+  setupIDT(0x16, (vaddr)&isr_wrapper_0x16);
+  setupIDT(0x17, (vaddr)&isr_wrapper_0x17);
+  setupIDT(0x18, (vaddr)&isr_wrapper_0x18);
+  setupIDT(0x19, (vaddr)&isr_wrapper_0x19);
+  setupIDT(0x1a, (vaddr)&isr_wrapper_0x1a);
+  setupIDT(0x1b, (vaddr)&isr_wrapper_0x1b);
+  setupIDT(0x1c, (vaddr)&isr_wrapper_0x1c);
+  setupIDT(0x1d, (vaddr)&isr_wrapper_0x1d);
+  setupIDT(0x1e, (vaddr)&isr_wrapper_0x1e);
+  setupIDT(0x1f, (vaddr)&isr_wrapper_0x1f);
+
+  // remaining vectors are programmable via IO-APIC
+  setupIDT(0x20, (vaddr)&isr_wrapper_0x20);
+  setupIDT(0x21, (vaddr)&isr_wrapper_0x21);
+  setupIDT(0x22, (vaddr)&isr_wrapper_0x22);
+  setupIDT(0x23, (vaddr)&isr_wrapper_0x23);
+  setupIDT(0x24, (vaddr)&isr_wrapper_0x24);
+  setupIDT(0x25, (vaddr)&isr_wrapper_0x25);
+  setupIDT(0x26, (vaddr)&isr_wrapper_0x26);
+  setupIDT(0x27, (vaddr)&isr_wrapper_0x27);
+  setupIDT(0x28, (vaddr)&isr_wrapper_0x28);
+  setupIDT(0x29, (vaddr)&isr_wrapper_0x29);
+  setupIDT(0x2a, (vaddr)&isr_wrapper_0x2a);
+  setupIDT(0x2b, (vaddr)&isr_wrapper_0x2b);
+  setupIDT(0x2c, (vaddr)&isr_wrapper_0x2c);
+  setupIDT(0x2d, (vaddr)&isr_wrapper_0x2d);
+  setupIDT(0x2e, (vaddr)&isr_wrapper_0x2e);
+  setupIDT(0x2f, (vaddr)&isr_wrapper_0x2f);
+  setupIDT(0x30, (vaddr)&isr_wrapper_0x30);
+  setupIDT(0x31, (vaddr)&isr_wrapper_0x31);
+  setupIDT(0x32, (vaddr)&isr_wrapper_0x32);
+  setupIDT(0x33, (vaddr)&isr_wrapper_0x33);
+  setupIDT(0x34, (vaddr)&isr_wrapper_0x34);
+  setupIDT(0x35, (vaddr)&isr_wrapper_0x35);
+  setupIDT(0x36, (vaddr)&isr_wrapper_0x36);
+  setupIDT(0x37, (vaddr)&isr_wrapper_0x37);
+  setupIDT(0x38, (vaddr)&isr_wrapper_0x38);
+  setupIDT(0x39, (vaddr)&isr_wrapper_0x39);
+  setupIDT(0x3a, (vaddr)&isr_wrapper_0x3a);
+  setupIDT(0x3b, (vaddr)&isr_wrapper_0x3b);
+  setupIDT(0x3c, (vaddr)&isr_wrapper_0x3c);
+  setupIDT(0x3d, (vaddr)&isr_wrapper_0x3d);
+  setupIDT(0x3e, (vaddr)&isr_wrapper_0x3e);
+  setupIDT(0x3f, (vaddr)&isr_wrapper_0x3f);
+  setupIDT(0x40, (vaddr)&isr_wrapper_0x40);
+  setupIDT(0x41, (vaddr)&isr_wrapper_0x41);
+  setupIDT(0x42, (vaddr)&isr_wrapper_0x42);
+  setupIDT(0x43, (vaddr)&isr_wrapper_0x43);
+  setupIDT(0x44, (vaddr)&isr_wrapper_0x44);
+  setupIDT(0x45, (vaddr)&isr_wrapper_0x45);
+  setupIDT(0x46, (vaddr)&isr_wrapper_0x46);
+  setupIDT(0x47, (vaddr)&isr_wrapper_0x47);
+  setupIDT(0x48, (vaddr)&isr_wrapper_0x48);
+  setupIDT(0x49, (vaddr)&isr_wrapper_0x49);
+  setupIDT(0x4a, (vaddr)&isr_wrapper_0x4a);
+  setupIDT(0x4b, (vaddr)&isr_wrapper_0x4b);
+  setupIDT(0x4c, (vaddr)&isr_wrapper_0x4c);
+  setupIDT(0x4d, (vaddr)&isr_wrapper_0x4d);
+  setupIDT(0x4e, (vaddr)&isr_wrapper_0x4e);
+  setupIDT(0x4f, (vaddr)&isr_wrapper_0x4f);
+  setupIDT(0x50, (vaddr)&isr_wrapper_0x50);
+  setupIDT(0x51, (vaddr)&isr_wrapper_0x51);
+  setupIDT(0x52, (vaddr)&isr_wrapper_0x52);
+  setupIDT(0x53, (vaddr)&isr_wrapper_0x53);
+  setupIDT(0x54, (vaddr)&isr_wrapper_0x54);
+  setupIDT(0x55, (vaddr)&isr_wrapper_0x55);
+  setupIDT(0x56, (vaddr)&isr_wrapper_0x56);
+  setupIDT(0x57, (vaddr)&isr_wrapper_0x57);
+  setupIDT(0x58, (vaddr)&isr_wrapper_0x58);
+  setupIDT(0x59, (vaddr)&isr_wrapper_0x59);
+  setupIDT(0x5a, (vaddr)&isr_wrapper_0x5a);
+  setupIDT(0x5b, (vaddr)&isr_wrapper_0x5b);
+  setupIDT(0x5c, (vaddr)&isr_wrapper_0x5c);
+  setupIDT(0x5d, (vaddr)&isr_wrapper_0x5d);
+  setupIDT(0x5e, (vaddr)&isr_wrapper_0x5e);
+  setupIDT(0x5f, (vaddr)&isr_wrapper_0x5f);
+  setupIDT(0x60, (vaddr)&isr_wrapper_0x60);
+  setupIDT(0x61, (vaddr)&isr_wrapper_0x61);
+  setupIDT(0x62, (vaddr)&isr_wrapper_0x62);
+  setupIDT(0x63, (vaddr)&isr_wrapper_0x63);
+  setupIDT(0x64, (vaddr)&isr_wrapper_0x64);
+  setupIDT(0x65, (vaddr)&isr_wrapper_0x65);
+  setupIDT(0x66, (vaddr)&isr_wrapper_0x66);
+  setupIDT(0x67, (vaddr)&isr_wrapper_0x67);
+  setupIDT(0x68, (vaddr)&isr_wrapper_0x68);
+  setupIDT(0x69, (vaddr)&isr_wrapper_0x69);
+  setupIDT(0x6a, (vaddr)&isr_wrapper_0x6a);
+  setupIDT(0x6b, (vaddr)&isr_wrapper_0x6b);
+  setupIDT(0x6c, (vaddr)&isr_wrapper_0x6c);
+  setupIDT(0x6d, (vaddr)&isr_wrapper_0x6d);
+  setupIDT(0x6e, (vaddr)&isr_wrapper_0x6e);
+  setupIDT(0x6f, (vaddr)&isr_wrapper_0x6f);
+  setupIDT(0x70, (vaddr)&isr_wrapper_0x70);
+  setupIDT(0x71, (vaddr)&isr_wrapper_0x71);
+  setupIDT(0x72, (vaddr)&isr_wrapper_0x72);
+  setupIDT(0x73, (vaddr)&isr_wrapper_0x73);
+  setupIDT(0x74, (vaddr)&isr_wrapper_0x74);
+  setupIDT(0x75, (vaddr)&isr_wrapper_0x75);
+  setupIDT(0x76, (vaddr)&isr_wrapper_0x76);
+  setupIDT(0x77, (vaddr)&isr_wrapper_0x77);
+  setupIDT(0x78, (vaddr)&isr_wrapper_0x78);
+  setupIDT(0x79, (vaddr)&isr_wrapper_0x79);
+  setupIDT(0x7a, (vaddr)&isr_wrapper_0x7a);
+  setupIDT(0x7b, (vaddr)&isr_wrapper_0x7b);
+  setupIDT(0x7c, (vaddr)&isr_wrapper_0x7c);
+  setupIDT(0x7d, (vaddr)&isr_wrapper_0x7d);
+  setupIDT(0x7e, (vaddr)&isr_wrapper_0x7e);
+  setupIDT(0x7f, (vaddr)&isr_wrapper_0x7f);
+  setupIDT(0x80, (vaddr)&isr_wrapper_0x80);
+  setupIDT(0x81, (vaddr)&isr_wrapper_0x81);
+  setupIDT(0x82, (vaddr)&isr_wrapper_0x82);
+  setupIDT(0x83, (vaddr)&isr_wrapper_0x83);
+  setupIDT(0x84, (vaddr)&isr_wrapper_0x84);
+  setupIDT(0x85, (vaddr)&isr_wrapper_0x85);
+  setupIDT(0x86, (vaddr)&isr_wrapper_0x86);
+  setupIDT(0x87, (vaddr)&isr_wrapper_0x87);
+  setupIDT(0x88, (vaddr)&isr_wrapper_0x88);
+  setupIDT(0x89, (vaddr)&isr_wrapper_0x89);
+  setupIDT(0x8a, (vaddr)&isr_wrapper_0x8a);
+  setupIDT(0x8b, (vaddr)&isr_wrapper_0x8b);
+  setupIDT(0x8c, (vaddr)&isr_wrapper_0x8c);
+  setupIDT(0x8d, (vaddr)&isr_wrapper_0x8d);
+  setupIDT(0x8e, (vaddr)&isr_wrapper_0x8e);
+  setupIDT(0x8f, (vaddr)&isr_wrapper_0x8f);
+  setupIDT(0x90, (vaddr)&isr_wrapper_0x90);
+  setupIDT(0x91, (vaddr)&isr_wrapper_0x91);
+  setupIDT(0x92, (vaddr)&isr_wrapper_0x92);
+  setupIDT(0x93, (vaddr)&isr_wrapper_0x93);
+  setupIDT(0x94, (vaddr)&isr_wrapper_0x94);
+  setupIDT(0x95, (vaddr)&isr_wrapper_0x95);
+  setupIDT(0x96, (vaddr)&isr_wrapper_0x96);
+  setupIDT(0x97, (vaddr)&isr_wrapper_0x97);
+  setupIDT(0x98, (vaddr)&isr_wrapper_0x98);
+  setupIDT(0x99, (vaddr)&isr_wrapper_0x99);
+  setupIDT(0x9a, (vaddr)&isr_wrapper_0x9a);
+  setupIDT(0x9b, (vaddr)&isr_wrapper_0x9b);
+  setupIDT(0x9c, (vaddr)&isr_wrapper_0x9c);
+  setupIDT(0x9d, (vaddr)&isr_wrapper_0x9d);
+  setupIDT(0x9e, (vaddr)&isr_wrapper_0x9e);
+  setupIDT(0x9f, (vaddr)&isr_wrapper_0x9f);
+  setupIDT(0xa0, (vaddr)&isr_wrapper_0xa0);
+  setupIDT(0xa1, (vaddr)&isr_wrapper_0xa1);
+  setupIDT(0xa2, (vaddr)&isr_wrapper_0xa2);
+  setupIDT(0xa3, (vaddr)&isr_wrapper_0xa3);
+  setupIDT(0xa4, (vaddr)&isr_wrapper_0xa4);
+  setupIDT(0xa5, (vaddr)&isr_wrapper_0xa5);
+  setupIDT(0xa6, (vaddr)&isr_wrapper_0xa6);
+  setupIDT(0xa7, (vaddr)&isr_wrapper_0xa7);
+  setupIDT(0xa8, (vaddr)&isr_wrapper_0xa8);
+  setupIDT(0xa9, (vaddr)&isr_wrapper_0xa9);
+  setupIDT(0xaa, (vaddr)&isr_wrapper_0xaa);
+  setupIDT(0xab, (vaddr)&isr_wrapper_0xab);
+  setupIDT(0xac, (vaddr)&isr_wrapper_0xac);
+  setupIDT(0xad, (vaddr)&isr_wrapper_0xad);
+  setupIDT(0xae, (vaddr)&isr_wrapper_0xae);
+  setupIDT(0xaf, (vaddr)&isr_wrapper_0xaf);
+  setupIDT(0xb0, (vaddr)&isr_wrapper_0xb0);
+  setupIDT(0xb1, (vaddr)&isr_wrapper_0xb1);
+  setupIDT(0xb2, (vaddr)&isr_wrapper_0xb2);
+  setupIDT(0xb3, (vaddr)&isr_wrapper_0xb3);
+  setupIDT(0xb4, (vaddr)&isr_wrapper_0xb4);
+  setupIDT(0xb5, (vaddr)&isr_wrapper_0xb5);
+  setupIDT(0xb6, (vaddr)&isr_wrapper_0xb6);
+  setupIDT(0xb7, (vaddr)&isr_wrapper_0xb7);
+  setupIDT(0xb8, (vaddr)&isr_wrapper_0xb8);
+  setupIDT(0xb9, (vaddr)&isr_wrapper_0xb9);
+  setupIDT(0xba, (vaddr)&isr_wrapper_0xba);
+  setupIDT(0xbb, (vaddr)&isr_wrapper_0xbb);
+  setupIDT(0xbc, (vaddr)&isr_wrapper_0xbc);
+  setupIDT(0xbd, (vaddr)&isr_wrapper_0xbd);
+  setupIDT(0xbe, (vaddr)&isr_wrapper_0xbe);
+  setupIDT(0xbf, (vaddr)&isr_wrapper_0xbf);
+  setupIDT(0xc0, (vaddr)&isr_wrapper_0xc0);
+  setupIDT(0xc1, (vaddr)&isr_wrapper_0xc1);
+  setupIDT(0xc2, (vaddr)&isr_wrapper_0xc2);
+  setupIDT(0xc3, (vaddr)&isr_wrapper_0xc3);
+  setupIDT(0xc4, (vaddr)&isr_wrapper_0xc4);
+  setupIDT(0xc5, (vaddr)&isr_wrapper_0xc5);
+  setupIDT(0xc6, (vaddr)&isr_wrapper_0xc6);
+  setupIDT(0xc7, (vaddr)&isr_wrapper_0xc7);
+  setupIDT(0xc8, (vaddr)&isr_wrapper_0xc8);
+  setupIDT(0xc9, (vaddr)&isr_wrapper_0xc9);
+  setupIDT(0xca, (vaddr)&isr_wrapper_0xca);
+  setupIDT(0xcb, (vaddr)&isr_wrapper_0xcb);
+  setupIDT(0xcc, (vaddr)&isr_wrapper_0xcc);
+  setupIDT(0xcd, (vaddr)&isr_wrapper_0xcd);
+  setupIDT(0xce, (vaddr)&isr_wrapper_0xce);
+  setupIDT(0xcf, (vaddr)&isr_wrapper_0xcf);
+  setupIDT(0xd0, (vaddr)&isr_wrapper_0xd0);
+  setupIDT(0xd1, (vaddr)&isr_wrapper_0xd1);
+  setupIDT(0xd2, (vaddr)&isr_wrapper_0xd2);
+  setupIDT(0xd3, (vaddr)&isr_wrapper_0xd3);
+  setupIDT(0xd4, (vaddr)&isr_wrapper_0xd4);
+  setupIDT(0xd5, (vaddr)&isr_wrapper_0xd5);
+  setupIDT(0xd6, (vaddr)&isr_wrapper_0xd6);
+  setupIDT(0xd7, (vaddr)&isr_wrapper_0xd7);
+  setupIDT(0xd8, (vaddr)&isr_wrapper_0xd8);
+  setupIDT(0xd9, (vaddr)&isr_wrapper_0xd9);
+  setupIDT(0xda, (vaddr)&isr_wrapper_0xda);
+  setupIDT(0xdb, (vaddr)&isr_wrapper_0xdb);
+  setupIDT(0xdc, (vaddr)&isr_wrapper_0xdc);
+  setupIDT(0xdd, (vaddr)&isr_wrapper_0xdd);
+  setupIDT(0xde, (vaddr)&isr_wrapper_0xde);
+  setupIDT(0xdf, (vaddr)&isr_wrapper_0xdf);
+  setupIDT(0xe0, (vaddr)&isr_wrapper_0xe0);
+  setupIDT(0xe1, (vaddr)&isr_wrapper_0xe1);
+  setupIDT(0xe2, (vaddr)&isr_wrapper_0xe2);
+  setupIDT(0xe3, (vaddr)&isr_wrapper_0xe3);
+  setupIDT(0xe4, (vaddr)&isr_wrapper_0xe4);
+  setupIDT(0xe5, (vaddr)&isr_wrapper_0xe5);
+  setupIDT(0xe6, (vaddr)&isr_wrapper_0xe6);
+  setupIDT(0xe7, (vaddr)&isr_wrapper_0xe7);
+  setupIDT(0xe8, (vaddr)&isr_wrapper_0xe8);
+  setupIDT(0xe9, (vaddr)&isr_wrapper_0xe9);
+  setupIDT(0xea, (vaddr)&isr_wrapper_0xea);
+  setupIDT(0xeb, (vaddr)&isr_wrapper_0xeb);
+  setupIDT(0xec, (vaddr)&isr_wrapper_0xec);
+  setupIDT(0xed, (vaddr)&isr_wrapper_0xed);
+  setupIDT(0xee, (vaddr)&isr_wrapper_0xee);
+  setupIDT(0xef, (vaddr)&isr_wrapper_0xef);
+  setupIDT(0xf0, (vaddr)&isr_wrapper_0xf0);
+  setupIDT(0xf1, (vaddr)&isr_wrapper_0xf1);
+  setupIDT(0xf2, (vaddr)&isr_wrapper_0xf2);
+  setupIDT(0xf3, (vaddr)&isr_wrapper_0xf3);
+  setupIDT(0xf4, (vaddr)&isr_wrapper_0xf4);
+  setupIDT(0xf5, (vaddr)&isr_wrapper_0xf5);
+  setupIDT(0xf6, (vaddr)&isr_wrapper_0xf6);
+  setupIDT(0xf7, (vaddr)&isr_wrapper_0xf7);
+  setupIDT(0xf8, (vaddr)&isr_wrapper_0xf8);
+  setupIDT(0xf9, (vaddr)&isr_wrapper_0xf9);
+  setupIDT(0xfa, (vaddr)&isr_wrapper_0xfa);
+  setupIDT(0xfb, (vaddr)&isr_wrapper_0xfb);
+  setupIDT(0xfc, (vaddr)&isr_wrapper_0xfc);
+  setupIDT(0xfd, (vaddr)&isr_wrapper_0xfd);
+  setupIDT(0xfe, (vaddr)&isr_wrapper_0xfe);
+  setupIDT(0xff, (vaddr)&isr_wrapper_0xff);
+}
+
+template<bool irq>
+class IsrEntry {
+  mword* frame;
+  constexpr mword* rip()    const { return frame;   }
+  constexpr mword* cs()     const { return frame+1; }
+  constexpr mword* rflags() const { return frame+2; }
+  constexpr mword* rsp()    const { return frame+3; }
+  constexpr mword* ss()     const { return frame+4; }
+public:
+  IsrEntry(mword* is) : frame(is) {
+    if (irq) MappedAPIC()->sendEOI();
+    if (Processor::userSegment(*cs())) CPU::SwapGS();
+    LocalProcessor::lockFake();
+    kernelSpace.runKernelInvalidation();
+  }
+  ~IsrEntry() {
+    LocalProcessor::unlockFake();
+    if (Processor::userSegment(*cs())) {
+      checkSignals();
+      LocalProcessor::setKernelStack();
+      CPU::SwapGS();
+    }
+  }
+  void checkSignals() {
+    Process& p = CurrProcess();
+    if (p.getSignalHandler()) {         // TODO: only if signal posted
+      mword** userSP = (mword**)rsp();  // access user stack
+      *userSP -= 1;                     // make room for return address
+      **userSP = *rip();                // put return address on user stack
+      *userSP -= 1;                     // make room for signal number
+      **userSP = 0xdeadbeef;            // put signal number on user stack
+      *rip() = p.getSignalHandler();    // return to sighandler from ISR
+    }                                   // TODO: else kill thread/process
+  }
+};
+
+extern "C" void exception_handler_0x00(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("DIVIDE ERROR @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x01(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("DEBUG @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x02(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("NMI @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x03(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("BREAKPOINT @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x04(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("OVERFLOW @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x05(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("BOUND RANGE EXCEEDED @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x06(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("INVALID OPCODE @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x07(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("DEVICE NOT AVAILABLE @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_errcode_0x08(mword* isrFrame, mword ec) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("DOUBLE FAULT @ ", FmtHex(*isrFrame), " / error: ", FmtHex(ec));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x09(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("COPROCESSOR SEGMENT OVERRUN @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_errcode_0x0a(mword* isrFrame, mword ec) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("INVALID TSS @ ", FmtHex(*isrFrame), " / error: ", FmtHex(ec));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_errcode_0x0b(mword* isrFrame, mword ec) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("SEGMENT NOT PRESENT @ ", FmtHex(*isrFrame), " / error: ", FmtHex(ec));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_errcode_0x0c(mword* isrFrame, mword ec) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("STACK FAULT @ ", FmtHex(*isrFrame), " / error: ", FmtHex(ec));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_errcode_0x0d(mword* isrFrame, mword ec) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("GENERAL PROTECTION FAULT @ ", FmtHex(*isrFrame), " / error: ", FmtHex(ec));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_errcode_0x0e(mword* isrFrame, mword ec) {
+  IsrEntry<false> ie(isrFrame);
+  vaddr da = CPU::readCR2();
+  if (Paging::fault(da, *LocalProcessor::getFrameManager())) return;
+  KERR::outl("PAGE FAULT @ ", FmtHex(*isrFrame), " / data: ", FmtHex(da), " / flags:", Paging::PageFaultFlags(ec));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x10(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("FPU ERROR @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_errcode_0x11(mword* isrFrame, mword ec) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("ALIGNMENT CHECK @ ", FmtHex(*isrFrame), " / error: ", FmtHex(ec));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x12(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("MACHINE CHECK @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x13(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("SIMD FP @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_0x14(mword* isrFrame) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("VIRTUALIZATION @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void exception_handler_undefined(mword* isrFrame, mword vec) {
+  IsrEntry<false> ie(isrFrame);
+  KERR::outl("UNDEFINED EXCEPTION ", FmtHex(vec), " @ ", FmtHex(*isrFrame));
+  Reboot(*isrFrame);
+}
+
+extern "C" void irq_handler_async(mword* isrFrame, mword idx) {
+  IsrEntry<true> ie(isrFrame);
+  irqMask.set<true>(idx);
+#if TESTING_REPORT_INTERRUPTS
+  KERR::out1(" AI:", FmtHex(idx));
+#endif
+}
+
+extern "C" void irq_handler_0xe0(mword* isrFrame) { // APIC::WakeIPI
+  IsrEntry<true> ie(isrFrame);
+  LocalProcessor::getScheduler()->preempt();
+}
+
+extern "C" void irq_handler_0xed(mword* isrFrame) { // APIC::PreemptIPI
+  IsrEntry<true> ie(isrFrame);
+  LocalProcessor::getScheduler()->preempt();
+}
+
+extern "C" void irq_handler_0xee(mword* isrFrame) { // APIC::TestIPI
+  IsrEntry<true> ie(isrFrame);
+  if (tipiHandler) {
+    tipiHandler();
+  } else {
+    KERR::outl("NO HANDLER FOR TEST IPI @ ", FmtHex(*isrFrame));
+    Reboot();
+  }
+}
+
+extern "C" void irq_handler_0xef(mword* isrFrame) { // APIC::StopIPI
+  for (;;) CPU::Halt();
+}
+
+extern "C" void irq_handler_0xf0(mword* isrFrame) { // PIT interrupt
+  IsrEntry<true> ie(isrFrame);
+  Clock::ticker();
+#if TESTING_REPORT_INTERRUPTS
+  KERR::out1(" PIT");
+#endif
+}
+
+extern "C" void irq_handler_0xf7(mword* isrFrame) { // parallel interrupt, spurious no problem
+  IsrEntry<true> ie(isrFrame);
+  KERR::out1(" parallel");
+}
+
+extern "C" void irq_handler_0xf8(mword* isrFrame) { // RTC interrupt
+  IsrEntry<true> ie(isrFrame);
+  rtc.staticInterruptHandler();          // RTC processing
+#if TESTING_REPORT_INTERRUPTS
+  KERR::out1(" RTC");
+#endif
+  if (!irqMask.empty()) asyncIrqSem.V(); // check interrupts
+  Timeout::checkExpiry(Clock::now());    // check timeout queue
+  Machine::rrPreemptIPI(rtc.tick());     // simulate APIC timer interrupts
+}
+
+extern "C" void irq_handler_0xf9(mword* isrFrame) { // spuriously seen
+  IsrEntry<true> ie(isrFrame);
+  KERR::out1(" IRQ-F9");
+}
+
+extern "C" void irq_handler_0xfc(mword* isrFrame) { // mouse interrupt
+  IsrEntry<true> ie(isrFrame);
+  KERR::out1(" mouse");
+}
+
+extern "C" void irq_handler_0xff(mword* isrFrame) { // bochs quirk?
+  IsrEntry<true> ie(isrFrame);
+  KERR::out1(" IRQ-FF");
+}
+
+void Breakpoint2(vaddr ia) {
+  asm volatile("nop");
+}
+
+void Steppoint() {
+  while (CPU::in8(0x64) & 0x01) CPU::in8(0x60); // clear read buffer
+  while (!(CPU::in8(0x64) & 0x01));        // wait for any key press
+}
+
+void Reboot(vaddr ia) {
+  asm volatile("cli");                // disable interrupts
+  Breakpoint(ia);
+#if 1
+  for (mword i = 0; i < Machine::getProcessorCount(); i++) {
+    if (i != LocalProcessor::getIndex()) Machine::sendIPI(i, APIC::StopIPI);
+  }
+  mword rbp;
+  asm volatile("mov %%rbp, %0" : "=r"(rbp));
+  KOUT::outl();
+  for (int i = 0; i < 20 && rbp != 0; i += 1) {
+    KOUT::outl("XBT: ", FmtHex(*(mword*)(rbp + sizeof(mword))));
+    rbp = *(mword*)(rbp);
+  }
+  KOUT::outl();
+#endif
+  Steppoint();
+  loadIDT(0,0);                       // load empty IDT
+  asm volatile("int $0xff");          // trigger triple fault
+  unreachable();
+}
+
+extern "C" void KosReboot() { Reboot(); }
diff --git a/src/machine/Machine.cc b/src/machine/Machine.cc
index d10deb0..81d33eb 100644
--- a/src/machine/Machine.cc
+++ b/src/machine/Machine.cc
@@ -115,6 +115,15 @@ struct IrqInfo {
 static Bitmap<MaxIrqCount> irqMask;     // IRQ bitmap
 static Semaphore asyncIrqSem;
 
+
+
+
+Scheduler* Machine::getScheduler(mword core)
+{
+  return processorTable[core].getSchedulerProcess();
+
+}
+
 // init routine for APs: on boot stack and using identity paging
 void Machine::initAP(mword idx) {
   KASSERT1(idx == apIndex, idx);
diff --git a/src/machine/Machine.h b/src/machine/Machine.h
index d4182a3..a0da075 100644
--- a/src/machine/Machine.h
+++ b/src/machine/Machine.h
@@ -25,6 +25,7 @@ class Thread;
 class Machine : public NoObject {
   friend void initGdb(mword); // initGdb calls setupIDT to redirect exception handlers
 
+  
   static mword processorCount;
 
   static void setupIDT(uint32_t, paddr, uint32_t = 0)  __section(".boot.text");
@@ -38,6 +39,7 @@ class Machine : public NoObject {
   static void bootCleanup();
 
 public:
+  static Scheduler* getScheduler(mword core);
   static void initAP(mword idx)                        __section(".boot.text");
   static void initBSP(mword mag, vaddr mb, mword idx)  __section(".boot.text");
   static void bootMain();
@@ -55,6 +57,9 @@ public:
 
 void Breakpoint2(vaddr ia = 0) __ninline;
 
+
+
+
 static inline void Breakpoint(vaddr ia = 0) {
   asm volatile( "xchg %%bx, %%bx" ::: "memory" );
   Breakpoint2(ia);
diff --git a/src/machine/Processor.h b/src/machine/Processor.h
index 2c54b1b..0ae10e5 100644
--- a/src/machine/Processor.h
+++ b/src/machine/Processor.h
@@ -89,6 +89,16 @@ class Processor {
   }
 
 public:
+
+  static Scheduler* getSchedulerProcess()
+  {
+        Scheduler* x;
+    asm volatile("movq %%gs:%c1, %0" : "=r"(x) : "i"(offsetof(Processor, scheduler)));
+    return x;
+
+  }
+
+  
   Processor() : lockCount(1), currThread(nullptr), currAS(nullptr),
     userPI(nullptr), kernPI(nullptr), scheduler(nullptr),
     frameManager(nullptr), index(0), apicID(0), systemID(0) {}
@@ -110,6 +120,7 @@ class LocalProcessor {
   }
 
 public:
+  
   static void initInterrupts(bool irqs);
   static mword getLockCount() {
     mword x;
diff --git a/src/main/InitProcess.cc b/src/main/InitProcess.cc
index 053e8d5..e2e1add 100644
--- a/src/main/InitProcess.cc
+++ b/src/main/InitProcess.cc
@@ -18,14 +18,14 @@
 
 int InitProcess() {
   Process* p0 = knew<Process>();
-  p0->exec("systest");
-#if !TESTING_KEYCODE_LOOP
+  p0->exec("schedAffinityTest");
+  /*#if !TESTING_KEYCODE_LOOP
   Process* p1 = knew<Process>();
   p1->exec("kbloop");
 #endif
   Process* p2 = knew<Process>();
   p2->exec("threadtest");
   Process* p3 = knew<Process>();
-  p3->exec("manythread");
+  p3->exec("manythread");*/
   return 0;
 }
diff --git a/src/runtime/Runtime.h b/src/runtime/Runtime.h
index dfe7125..4bd3e4b 100644
--- a/src/runtime/Runtime.h
+++ b/src/runtime/Runtime.h
@@ -69,8 +69,8 @@ namespace Runtime {
 
   struct RealLock {
     RealLock() { LocalProcessor::lock(true); }    // disable IRQs
-    // destructor not needed
-  };
+    ~RealLock() { LocalProcessor::unlock(true); } // deflate lock count, enable IRQs 
+ };
 
   /**** AddressSpace-related interface ****/
 
diff --git a/src/runtime/Scheduler.cc b/src/runtime/Scheduler.cc
index 7d760c3..97ab425 100644
--- a/src/runtime/Scheduler.cc
+++ b/src/runtime/Scheduler.cc
@@ -19,6 +19,16 @@
 #include "runtime/Stack.h"
 #include "runtime/Thread.h"
 #include "kernel/Output.h"
+#include "include/syscalls.h"
+//#include <iostream>
+
+#define CORE_ONE 0x0000000000000001
+#define CORE_TWO 0x0000000000000002
+#define CORE_THREE 0x0000000000000004
+#define CORE_FOUR 0x0000000000000008
+#define NUM_CORES 4
+
+
 
 Scheduler::Scheduler() : readyCount(0), preemption(0), resumption(0), partner(this) {
   Thread* idleThread = Thread::create((vaddr)idleStack, minimumStack);
@@ -44,7 +54,9 @@ inline void Scheduler::switchThread(Scheduler* target, Args&... a) {
   CHECK_LOCK_MIN(sizeof...(Args));
   Thread* nextThread;
   readyLock.acquire();
-  for (mword i = 0; i < (target ? idlePriority : maxPriority); i += 1) {
+//  for (mword i = 0; i < (target ? idlePriority : maxPriority); i += 1) {
+  for (mword i = 0; i < ((target == this) ? idlePriority : maxPriority);
+i += 1) {
     if (!readyQueue[i].empty()) {
       nextThread = readyQueue[i].pop_front();
       readyCount -= 1;
@@ -111,11 +123,81 @@ void Scheduler::resume(Thread& t) {
   else Runtime::getScheduler()->enqueue(t);
 }
 
+
+
 void Scheduler::preempt() {               // IRQs disabled, lock count inflated
 #if TESTING_NEVER_MIGRATE
   switchThread(this);
 #else /* migration enabled */
-  Scheduler* target = Runtime::getCurrThread()->getAffinity();
+  Scheduler *target = nullptr;
+  mword affinityMask = Runtime::getCurrThread()->getAffinityMask();
+  Scheduler *sched[NUM_CORES];
+  Scheduler *sched_current = nullptr;
+
+  for(int i = 0; i < NUM_CORES; i++)
+    {
+      sched[i] = nullptr;
+    }
+
+  
+  if( affinityMask == 0 ) {
+	  /* use Martin's code when no affinity is set via bit mask */
+	  target =  Runtime::getCurrThread()->getAffinity();
+
+
+  }  else {
+
+    /*
+      Check each core to see if it is active and get the Scheduler for it
+     */
+    
+     mword j = 1;
+     for(mword i = 0; i < NUM_CORES; i++)
+       {
+     	if((affinityMask & j) == j)
+     	  {
+     	    sched[i] = Machine::getScheduler(i);
+     	  }
+
+     	j*=2;
+       }
+
+
+     /*
+       find the lowest ready count and set the target ready count to it.
+      */
+    for(mword i = 0; i < NUM_CORES; i++)
+      {
+	if(sched[i] != nullptr)
+	  {
+	    if(sched_current == nullptr)
+	      {
+		sched_current = sched[i];
+	      }
+	    else
+	      {
+		if(sched_current->readyCount > sched[i]->readyCount)
+		  {
+		    sched_current = sched[i];
+		  }
+	      }
+	  }
+	
+      }
+    target = sched_current;
+    
+
+
+
+    /* CPSC457l: Add code here to scan the affinity mask
+      * and select the processor with the smallest ready count.
+      * Set the scheduler of the selected processor as target
+      * switchThread(target) migrates the current thread to 
+      * specified target's ready queue
+      */
+
+  } 
+
 #if TESTING_ALWAYS_MIGRATE
   if (!target) target = partner;
 #else /* simple load balancing */
@@ -143,3 +225,8 @@ void Scheduler::terminate() {
   switchThread(nullptr);
   unreachable();
 }
+
+void Scheduler::yield(){
+  Runtime::RealLock rl;
+  preempt();
+}
diff --git a/src/runtime/Scheduler.h b/src/runtime/Scheduler.h
index bc86000..eae3fa8 100644
--- a/src/runtime/Scheduler.h
+++ b/src/runtime/Scheduler.h
@@ -34,7 +34,7 @@ class Scheduler {
   volatile mword resumption;
 
   Scheduler* partner;
-
+  
   template<typename... Args>
   inline void switchThread(Scheduler* target, Args&... a);
 
@@ -51,6 +51,7 @@ public:
   void suspend(BasicLock& lk);
   void suspend(BasicLock& lk1, BasicLock& lk2);
   void terminate() __noreturn;
+  void yield();
 };
 
 #endif /* _Scheduler_h_ */
diff --git a/src/runtime/Thread.h b/src/runtime/Thread.h
index a09bb0e..953e1e2 100644
--- a/src/runtime/Thread.h
+++ b/src/runtime/Thread.h
@@ -33,6 +33,9 @@ class Thread : public EmbeddedList<Thread>::Link {
 
   mword priority;           // scheduling priority
   bool affinity;            // stick with scheduler
+  cpu_set_t affinityMask;	 	 // stick with multiple schedulers
+  // affinity mask of 0 means that the thread can be scheduled on any processor  
+
   Scheduler* nextScheduler; // resume on same core (for now)
 
   Runtime::MachContext ctx;
@@ -47,7 +50,7 @@ protected:
 
   Thread(vaddr sb, size_t ss) :
     stackPointer(vaddr(this)), stackBottom(sb), stackSize(ss),
-    priority(defPriority), affinity(false), nextScheduler(nullptr),
+    priority(defPriority), affinity(false), affinityMask(0), nextScheduler(nullptr),
     state(Running), unblockInfo(nullptr) {}
 
   // called directly when creating idle thread(s)
@@ -81,6 +84,10 @@ public:
   }
 
   Thread* setPriority(mword p)      { priority = p; return this; }
+
+  void   setAffinityMask( cpu_set_t mask ) { affinityMask = mask; }
+  cpu_set_t  getAffinityMask() { return affinityMask; }
+
   Thread* setAffinity(Scheduler* s) { affinity = (nextScheduler = s); return this; }
   Scheduler* getAffinity() const    { return affinity ? nextScheduler : nullptr; }
 
diff --git a/src/ulib/#libKOS.cc# b/src/ulib/#libKOS.cc#
new file mode 100644
index 0000000..cf7a9aa
--- /dev/null
+++ b/src/ulib/#libKOS.cc#
@@ -0,0 +1,148 @@
+/******************************************************************************
+    Copyright © 2012-2015 Martin Karsten
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+******************************************************************************/
+#include "syscalls.h"
+#include "kostypes.h"
+
+#include <string.h>
+
+
+
+int signum = 0;
+
+extern "C" int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
+{
+  return syscallStub(SyscallNum::sched_setaffinity,pid,cpusetsize,mword(mask));
+}
+
+extern "C" int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
+{
+  return syscallStub(SyscallNum::sched_getaffinity,pid,cpusetsize,mword(mask));
+}
+
+
+extern "C" void _KOS_sigwrapper();
+
+extern "C" void _KOS_sighandler(mword s) {
+  signum = s;
+}
+
+extern "C" void _initialize_KOS_standard_library() {
+  syscallStub(SyscallNum::_init_sig_handler, (mword)_KOS_sigwrapper);
+}
+
+extern "C" void abort() { _exit(-1); }
+
+extern "C" void _free_r(_reent* r, void* ptr) { free(ptr); }
+extern "C" void* _malloc_r(_reent* r, size_t size) { return malloc(size); }
+extern "C" void* _calloc_r(_reent* r, size_t nmemb, size_t size) { return calloc(nmemb, size); }
+extern "C" void* _realloc_r(_reent* r, void* ptr, size_t size) { return realloc(ptr, size); }
+
+extern "C" void _exit(int) {
+  syscallStub(SyscallNum::_exit);
+  for (;;); // never reached...
+}
+
+extern "C" int open(const char *path, int oflag, ...) {
+  ssize_t ret = syscallStub(SyscallNum::open, mword(path), oflag);
+  if (ret < 0) { *__errno() = -ret; return -1; } else return ret;
+}
+
+extern "C" int close(int fildes) {
+  ssize_t ret = syscallStub(SyscallNum::close, fildes);
+  if (ret < 0) { *__errno() = -ret; return -1; } else return ret;
+}
+
+extern "C" ssize_t read(int fildes, void* buf, size_t nbyte) {
+  ssize_t ret = syscallStub(SyscallNum::read, fildes, mword(buf), nbyte);
+  if (ret < 0) { *__errno() = -ret; return -1; } else return ret;
+}
+
+extern "C" ssize_t write(int fildes, const void* buf, size_t nbyte) {
+  if (fildes == STDOUT_FILENO) {                      // copy stdout to stddbg
+    syscallStub(SyscallNum::write, STDDBG_FILENO, mword(buf), nbyte);
+  }
+  ssize_t ret = syscallStub(SyscallNum::write, fildes, mword(buf), nbyte);
+  if (ret < 0) { *__errno() = -ret; return -1; } else return ret;
+}
+
+extern "C" off_t lseek(int fildes, off_t offset, int whence) {
+  ssize_t ret = syscallStub(SyscallNum::lseek, fildes, offset, whence);
+  if (ret < 0) { *__errno() = -ret; return -1; } else return ret;
+}
+
+/*added by Priyaa*/
+extern "C" long get_core_count() {
+  return syscallStub(SyscallNum::get_core_count);
+}
+
+extern "C" pid_t getpid() {
+  return syscallStub(SyscallNum::getpid);
+}
+
+extern "C" pid_t getcid() {
+  return syscallStub(SyscallNum::getcid);
+}
+
+extern "C" int usleep(useconds_t usecs) {
+  return syscallStub(SyscallNum::getcid, usecs);
+}
+
+extern "C" void* mmap(void* addr, size_t len, int prot, int flags, int filedes, off_t off) {
+  void* newaddr = addr;
+  ssize_t ret = syscallStub(SyscallNum::_mmap, mword(&newaddr), len, prot|(flags<<4), filedes, off);
+  if (ret < 0) { *__errno() = -ret; return MAP_FAILED; } else return newaddr;
+}
+
+extern "C" int munmap(void* addr, size_t len) {
+  ssize_t ret = syscallStub(SyscallNum::_munmap, mword(addr), len);
+  if (ret < 0) { *__errno() = -ret; return -1; } else return ret;
+}
+
+extern "C" int privilege(void* func, mword a1, mword a2, mword a3, mword a4) {
+  return syscallStub(SyscallNum::privilege, (mword)func, a1, a2, a3, a4);
+}
+
+/******* dummy functions *******/
+
+extern "C" int fstat(int fildes, struct stat *buf) {
+  memset(buf, 0, sizeof(struct stat));
+  switch (fildes) {
+    case STDIN_FILENO:  buf->st_mode = S_IFCHR;
+    case STDOUT_FILENO: buf->st_mode = S_IFCHR;
+    case STDERR_FILENO: buf->st_mode = S_IFCHR;
+    default: buf->st_mode = S_IFREG;
+  }
+  return 0;
+}
+
+extern "C" char *getenv(const char *name) {
+  return nullptr;
+}
+
+extern "C" int isatty(int fildes) {
+  switch (fildes) {
+    case STDIN_FILENO:  return 1;
+    case STDOUT_FILENO: return 1;
+    case STDERR_FILENO: return 1;
+    default: return 0;
+  }
+}
+
+extern "C" int kill(pid_t pid, int sig) {
+  *__errno() = EINVAL;
+  return -1;
+}
diff --git a/src/ulib/libKOS.cc b/src/ulib/libKOS.cc
index 9c9b982..4a9e631 100644
--- a/src/ulib/libKOS.cc
+++ b/src/ulib/libKOS.cc
@@ -1,4 +1,4 @@
-/*****************************************************************************
+/******************************************************************************
     Copyright  2012-2015 Martin Karsten
 
     This program is free software: you can redistribute it and/or modify
@@ -15,36 +15,25 @@
     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
 #include "syscalls.h"
+#include "kostypes.h"
 
 #include <string.h>
 
-int signum = 0;
-
-/*
-
-REMEMBER MEEE
 
- */
 
+int signum = 0;
 
 extern "C" int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
 {
-
+  return syscallStub(SyscallNum::sched_setaffinity,pid,cpusetsize,mword(mask));
 }
 
 extern "C" int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
 {
-  return syscallStub(SyscallNum::sched_getaffinity);  
+  return syscallStub(SyscallNum::sched_getaffinity,pid,cpusetsize,mword(mask));
 }
 
 
-
-/*
-
-REMEMBER MEE
-
- */
-
 extern "C" void _KOS_sigwrapper();
 
 extern "C" void _KOS_sighandler(mword s) {
@@ -95,6 +84,11 @@ extern "C" off_t lseek(int fildes, off_t offset, int whence) {
   if (ret < 0) { *__errno() = -ret; return -1; } else return ret;
 }
 
+/*added by Priyaa*/
+extern "C" long get_core_count() {
+  return syscallStub(SyscallNum::get_core_count);
+}
+
 extern "C" pid_t getpid() {
   return syscallStub(SyscallNum::getpid);
 }
diff --git a/src/user/schedAffinityTest.cc b/src/user/schedAffinityTest.cc
new file mode 100644
index 0000000..d7c160a
--- /dev/null
+++ b/src/user/schedAffinityTest.cc
@@ -0,0 +1,131 @@
+#include <iostream>
+#include "syscalls.h"
+#include "pthread.h"
+
+using namespace std;
+
+#define MASK1 0x1  // 00001
+#define MASK2 0x3  // 00011
+#define MASK3 0x4  // 00100
+#define MASK4 0x8  // 01000
+#define MASK5 0x6  // 00110
+#define MASK6 0x10 // 10000
+
+#define REPETITION 5
+
+
+void* dummy (void *args) {
+   //pinning thread to core 1
+   cpu_set_t mask = MASK2;
+   sched_setaffinity( 0, sizeof(cpu_set_t), &mask );
+   int count = REPETITION; 
+   while (count--){
+		for( int i=0; i<1000000000; i++) asm("");
+	}
+}
+
+void whereAmI(){
+   /* test on which core the process is running */  
+   int count = REPETITION; 
+   while (count--){
+	   for( int i=0; i<100000000; i++) asm("");
+         cout << "I am running on core "<< getcid() << endl; 
+   }
+}
+
+void printAffinity( cpu_set_t affinityMask ){
+   mword cpuCount = get_core_count();
+	mword bitmask  = 0x1;
+   for( mword i=0; i<cpuCount; i++ ){
+		if( (affinityMask & (bitmask << i)) != 0 ){
+			cout << "Current process has affinity to core "<<i << endl;
+		}
+	}
+}
+
+int main() {
+
+     int err=5;
+   cout << "Test process is running on core "<< getcid() << endl; 
+ 
+   /* sched_setaffinity */
+   cout << endl << "SCHED_SETAFFINITY TEST 1" << endl;
+   cpu_set_t affinityMask = MASK6;
+   //cout << "Setting Mask to "<< affinityMask << " for pid 0 "<< endl; 
+      err = sched_setaffinity( 0, sizeof(cpu_set_t), &affinityMask );
+      //cout << "err is " << err << endl;
+   if( err == -1 ){
+      cout << "sched_setaffinity unsuccessful" << endl; 
+   } else {
+      //cout << "sched_setaffinity successful" << endl; 
+	   whereAmI();
+   }
+
+      cout << endl << "SCHED_SETAFFINITY TEST 2" << endl;
+   err = 5;
+   affinityMask = MASK1;
+   //cout << "Setting Mask to "<< affinityMask << " for pid 2" << endl; 
+   err = sched_setaffinity( 2, sizeof(cpu_set_t), &affinityMask );
+   if( err == -1 ){
+      cout << "sched_setaffinity unsuccessful"<< endl; 
+   }else {
+      //cout << "sched_setaffinity successful" << endl; 
+   	whereAmI();
+	}
+
+   cout << endl << "SCHED_SETAFFINITY TEST 3" << endl;
+   err = 5;
+   affinityMask = MASK1;
+   cout << "Setting Mask to "<< affinityMask << " for pid 0 " << endl;
+   err = sched_setaffinity( 0, sizeof(cpu_set_t), &affinityMask );
+   if( err == -1 ){
+      cout << "sched_setaffinity unsuccessful" << endl; 
+   }else{
+      //cout << "sched_setaffinity successful " << endl; 
+   	whereAmI();
+	}
+
+   
+   cout << endl << "SCHED_SETAFFINITY TEST 4" << endl;
+   err = 5;
+   affinityMask = MASK5;
+   //cout << "Setting Mask to "<< affinityMask << " for pid 0 " << endl; 
+   err = sched_setaffinity( 0, sizeof(cpu_set_t), &affinityMask );
+   if( err == -1 ){
+      cout << "sched_setaffinity unsuccessful" << endl; 
+   }else{
+      //cout << "sched_setaffinity successful" << endl;
+
+   	whereAmI();
+	}
+
+   pthread_t t1;
+   pthread_create(&t1, nullptr, dummy, nullptr);
+   whereAmI();
+   whereAmI();
+   whereAmI();
+
+   /* sched_getaffinity */
+   cout << endl << "SCHED_GETAFFINITY TEST 1" << endl;
+   err = 5;
+   err = sched_getaffinity( 2, sizeof(cpu_set_t), &affinityMask );
+
+   if( err == -1 ){
+      cout << "sched_getaffinity unsuccessful" << endl; 
+   }else{
+  		printAffinity(affinityMask);
+   }
+
+    
+   cout << endl << "SCHED_GETAFFINITY TEST 2" << endl;
+   err = 5;
+   err = sched_getaffinity( 0, sizeof(cpu_set_t), &affinityMask );
+   if( err == -1 ){
+      cout << "sched_getaffinity unsuccessful" << endl; 
+   }else{
+  		printAffinity(affinityMask);
+		}
+
+#if 0
+#endif
+}
diff --git a/test.txt b/test.txt
deleted file mode 100644
index e000b09..0000000
--- a/test.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-asdf
-
-Hey everybody!
